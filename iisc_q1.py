# -*- coding: utf-8 -*-
"""IISC_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T2z-qbsZoN0O2oHbeIgyy-JCTSJctIa2
"""

import matplotlib.pyplot as plt
import osmnx as ox
import matplotlib.colors as colors
import matplotlib.cm as cm
import networkx as nx
import time
from datetime import datetime
import pandas as pd
df = pd.read_csv("bike_data_new.csv")
df.head()
# print(type(df["ended_at"]))


def time_diff(t2, t1):
    et = t2
    st = t1
    # print(st, et)
    delta = datetime.strptime(et, "%d-%m-%Y %H:%M") - \
        datetime.strptime(st, "%d-%m-%Y %H:%M")
    return delta.total_seconds()/60

# time_diff("01-02-2023 00:03","01-02-2023 00:03")

# TODO -- Task 1


start_time = time.time()

# print(df.loc[0]['duration']
df["duration"] = [0 for _ in range(df['trip_id'].count())]
# print(df['trip_id'].count())
ct = 0
for i in range(df['trip_id'].count()-1):
    if (df['start_lat'][i] == df['end_lat'][i]) & (df['start_lng'][i] == df['end_lng'][i]):
        ct += 1
    if (df.loc[i]["ended_at"] == df.loc[i]["started_at"]):
        df['duration'][i] = 0
        continue
    temp = time_diff(df["ended_at"][i], df["started_at"][i])
    if (temp > 0):
        df['duration'][i] = temp

# df.head()
     # Remove all trips with duration 0 minutes
df = df[df['duration'] > 0]

# Find the maximum and minimum duration of the trips
max_duration = df['duration'].max()
min_duration = df['duration'].min()

# Calculate the total number of trips corresponding to the minimum duration
num_min_duration_trips = df[df['duration'] == min_duration].shape[0]

# Calculate the percentage of total circular trips

num_circular_trips = ct
total_trips = df.shape[0]
percent_circular_trips = (num_circular_trips / total_trips) * 100

# Calculate the runtime of the function
end_time = time.time()
runtime = end_time - start_time

# Print the requested values on the console
print("Number of zero duration trip is :", 6867-df['trip_id'].count())
print("Maximum duration of trip (in minutes):", max_duration)
print("Minimum duration of trip (in minutes):", min_duration)
print("Total number of trips corresponding to the minimum duration:",
      num_min_duration_trips)
print("Percentage of total circular trips:", percent_circular_trips)
print("Runtime of the function (in seconds):", runtime)
# df = df[df["diff"]>0]
# df.head()

# TODO -- Task 2


df['started_at'] = pd.to_datetime(df['started_at'])
df['ended_at'] = pd.to_datetime(df['ended_at'])

# Filter the dataframe to include only trips starting between 06:00 AM and 06:00 PM
df_filtered = df.loc[(df['started_at'].dt.hour >= 6) &
                     (df['started_at'].dt.hour < 18)]
# print(df_filtered.head())
# Create a dictionary of end locations for each trip
end_locations = {}
for i, trip in df_filtered.iterrows():
    # print(i,trip)
    end_location = (trip['end_lat'], trip['end_lng'])
    end_time = trip['ended_at']
    # print("i",i,end_location,end_time)
    if end_location in end_locations:
        end_locations[end_location].append(end_time)
    else:
        end_locations[end_location] = [end_time]

# Find the total number of feasible pairs of trips
num_feasible_pairs = 0
for i, trip in df_filtered.iterrows():
    start_location = (trip['start_lat'], trip['start_lng'])
    end_time = trip['ended_at']
    if start_location in end_locations:
        for time in end_locations[start_location]:
            if end_time <= time:
                num_feasible_pairs += 1

# Print the total feasible pairs of trips and runtime
print(f"Total feasible pairs of trips: {num_feasible_pairs}")


# TODO -- Task 3


df = df.loc[df['trip_id'].isin(range(1, 101))]

# Find the number of unique depots used to serve these trips
num_depots = df[['start_lat', 'start_lng', 'end_lat', 'end_lng']].nunique()

# Download the graph for the study area
place_name = "Washington, DC, USA"
G = ox.graph_from_point((38.20, -77.10), dist=30000, network_type='walk')

cmap = cm.get_cmap('tab20', len(G))
print(G.nodes.data())
# convert node and edge attributes to lists
node_colors = [colors.rgb2hex(cmap(i)[:3]) for i in range(len(G))]
# edge_colors = [node_colors[G.nodes[n]['osmid']] for u, v, n in G.edges(keys=True)]

# plot the street network with colored edges
fig, ax = ox.plot_graph(G, node_color=node_colors, node_size=0,
                        edge_linewidth=0.5, show=False, close=False)

# show the plot
plt.show()

# Find the nearest node in the graph corresponding to each depot
start_time = time.time()
G_projected = ox.project_graph(G)
depots = df[['start_lat', 'start_lng', 'end_lat', 'end_lng']].values
depot_lats = depots[:, [0, 2]].flatten()
depot_lngs = depots[:, [1, 3]].flatten()
depot_nodes = ox.nearest_nodes(G_projected, depot_lats, depot_lngs)
# print(depots)
# print(depot_lats)
# print(depot_lngs)
# print(depot_nodes)
# Calculate the shortest path distance between every pair of nodes
print(set(depot_nodes))
distances = []
for i in range(len(depot_nodes)):
    for j in range(i+1, len(depot_nodes)):
        try:
            distance = nx.shortest_path_length(
                G, depot_nodes[i], depot_nodes[j], weight='length')
            if distance > 0:
                distances.append(distance)
        except nx.NetworkXNoPath:
            pass
        # print(f"Shortest distace between {depot_nodes[i]} and {depot_nodes[j]} is : {distance}")

# Print the number of unique depots and the shortest path distance statistics

unique_depots = set(df['start_lat'].unique()) | set(df['end_lat'].unique())
num_depots = len(unique_depots)
print("Number of unique depots used:", len(set(depot_nodes)))
print(f"Total runtime: {time.time()-start_time:.2f} seconds")
if distances:
    print(f"Minimum distance: {min(distances)} meters")
    print(f"Maximum distance: {max(distances)} meters")
else:
    print("No feasible paths found between any pair of depots.")
